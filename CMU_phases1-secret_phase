PHASE1:
On the the phase_1 function you see it pushes a value on an address
gdb-peda$ disas phase_1
Dump of assembler code for function phase_1:
   0x08048b20 <+0>:	push   ebp
   0x08048b21 <+1>:	mov    ebp,esp
   0x08048b23 <+3>:	sub    esp,0x8
   0x08048b26 <+6>:	mov    eax,DWORD PTR [ebp+0x8]
   0x08048b29 <+9>:	add    esp,0xfffffff8
   0x08048b2c <+12>:	push   0x80497c0
   0x08048b31 <+17>:	push   eax
   0x08048b32 <+18>:	call   0x8049030 <strings_not_equal>
   0x08048b37 <+23>:	add    esp,0x10
   0x08048b3a <+26>:	test   eax,eax
   0x08048b3c <+28>:	je     0x8048b43 <phase_1+35>
   0x08048b3e <+30>:	call   0x80494fc <explode_bomb>
   0x08048b43 <+35>:	mov    esp,ebp
   0x08048b45 <+37>:	pop    ebp
   0x08048b46 <+38>:	ret    
End of assembler dump.
gdb-peda$ x/s 0x80497c0
0x80497c0:	"Public speaking is very easy."

Phase1 `flag` =>  Public speaking is very easy.

PHASE2:
gdb-peda$ disas phase_2
Dump of assembler code for function phase_2:
   0x08048b48 <+0>:	push   ebp
   0x08048b49 <+1>:	mov    ebp,esp
   0x08048b4b <+3>:	sub    esp,0x20
   0x08048b4e <+6>:	push   esi
   0x08048b4f <+7>:	push   ebx
   0x08048b50 <+8>:	mov    edx,DWORD PTR [ebp+0x8]
   0x08048b53 <+11>:	add    esp,0xfffffff8
   0x08048b56 <+14>:	lea    eax,[ebp-0x18]
   0x08048b59 <+17>:	push   eax
   0x08048b5a <+18>:	push   edx
   0x08048b5b <+19>:	call   0x8048fd8 <read_six_numbers>
   0x08048b60 <+24>:	add    esp,0x10
   0x08048b63 <+27>:	cmp    DWORD PTR [ebp-0x18],0x1
   0x08048b67 <+31>:	je     0x8048b6e <phase_2+38>
   0x08048b69 <+33>:	call   0x80494fc <explode_bomb>
   0x08048b6e <+38>:	mov    ebx,0x1
   0x08048b73 <+43>:	lea    esi,[ebp-0x18]
   0x08048b76 <+46>:	lea    eax,[ebx+0x1]
   0x08048b79 <+49>:	imul   eax,DWORD PTR [esi+ebx*4-0x4]
   0x08048b7e <+54>:	cmp    DWORD PTR [esi+ebx*4],eax
   0x08048b81 <+57>:	je     0x8048b88 <phase_2+64>
   0x08048b83 <+59>:	call   0x80494fc <explode_bomb>
   0x08048b88 <+64>:	inc    ebx
   0x08048b89 <+65>:	cmp    ebx,0x5
   0x08048b8c <+68>:	jle    0x8048b76 <phase_2+46>
   0x08048b8e <+70>:	lea    esp,[ebp-0x28]
   0x08048b91 <+73>:	pop    ebx
   0x08048b92 <+74>:	pop    esi
   0x08048b93 <+75>:	mov    esp,ebp
   0x08048b95 <+77>:	pop    ebp
   0x08048b96 <+78>:	ret    
End of assembler dump.

You can clearly see it needs 6 ints as an input
You can also verify it by goinf in the `read_six_numbers` function
   0x08049007 <+47>:	cmp    eax,0x5


You start the program on a debugger with a breakpoint on phase_2 function
You give the first flag you already know
It asks for a second input and you give six numbers ex. 1 2 3 4 5 6
You hit the breakpoint you previously set :)
You go instruction-instruction to be sure you don't miss anything
You see a cmp instruction, 
=> 0x8048b63 <phase_2+27>:	cmp    DWORD PTR [ebp-0x18],0x1

It checks if the first number you gave is 1.
We hold that in mind and continue instruction-instruction until we see something interesting
=> 0x8048b7e <phase_2+54>:	cmp    DWORD PTR [esi+ebx*4],eax


Hmmm
Let's see what the address on eax has in it.

gdb-peda$ x/d $eax

Nice, so our second input must be 2!
We AGAIN continue instruction-instruction till we see something interesting 

We again see the same instruction
We do the same
It is clear now the we are on a loop
gdb-peda$ x/d $eax

With the same logic our third number should be 6
We continue
But we set esi+$ebx*4 to the value of eax we gave so we won't hit explode_bomb 

gdb-peda$ x/d $esi+$ebx*4
0xffffcde8:	3
gdb-peda$ set *0xffffcde8=0x6

When we hit the cmp instruction the EAX is 0x18
0x18 = 24 
so our forth input must be 24 
We again continue 
But again we set esi+ebx*4 to the value of eax so we don't hit on explode_bomb function

gdb-peda$ x/d $esi+$ebx*4
0xffffcdec:	4
gdb-peda$ set *0xffffcdec=0x18

Continue(we could clearly understand the pattern but let's finish it the way i did it back then because i was dumb af)

Again we continue
Eax now becomes 0x78 = 120
Our fifth number must be 120
We again set our input to 120 so we won't hit explode_bomb function

gdb-peda$ x/d $esi+$ebx*4
0xffffcdf0:	5
gdb-peda$ set *0xffffcdf0=0x78

Continue

Now eax is 0x2d0 = 720
Sooo our last number must be 720

To sum up our input to bypass phase_2 must be:
1 2 6 24 120 720

I will finish it tomorrow :P :P
